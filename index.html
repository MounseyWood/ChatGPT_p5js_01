<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enhanced Cloth Simulation â€“ Educational</title>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  </head>
  <body>
    <script>
      // --- Global Variables & Arrays ---
      let cols = 30;
      let rows = 20;
      let spacing = 20;
      let clothPoints = [];
      let clothConstraints = [];
      // 2D arrays for different sets of points:
      let grid = [];       // grid corners
      let horizontal = []; // horizontal midpoints (between grid corners)
      let vertical = [];   // vertical midpoints
      let centers = [];    // center of each cell

      // Simulation parameters (default values updated by sliders)
      let friction = 0.98;
      let iterations = 5;
      let gravity = 0.4;
      let weight = 1.0;
      let windAmplitude = 0.2; // wind amplitude (will be controlled by slider)

      // Additional parameters for self-collision:
      let collisionThreshold = spacing * 0.5;  
      let repulsionFactor = 0.5;

      // Obstacle parameters:
      let obstacleX, obstacleY, obstacleRadius;

      // UI elements (sliders and buttons)
      let frictionSlider, iterationsSlider, gravitySlider, weightSlider, windSlider;
      let resetButton;

      // For point dragging.
      let dragPointIndex = null;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        // --- Create UI Controls ---
        resetButton = createButton("Reset Cloth");
        resetButton.position(20, 20);
        resetButton.style("font-size", "16px");
        resetButton.mousePressed(resetCloth);

        frictionSlider = createSlider(0.90, 1.0, 0.98, 0.01);
        frictionSlider.position(20, 60);
        frictionSlider.style("width", "200px");

        iterationsSlider = createSlider(1, 10, 5, 1);
        iterationsSlider.position(20, 100);
        iterationsSlider.style("width", "200px");

        gravitySlider = createSlider(0, 1, 0.4, 0.01);
        gravitySlider.position(20, 140);
        gravitySlider.style("width", "200px");

        weightSlider = createSlider(0.5, 2.0, 1.0, 0.1);
        weightSlider.position(20, 180);
        weightSlider.style("width", "200px");

        windSlider = createSlider(0, 1, 0.2, 0.01);
        windSlider.position(20, 220);
        windSlider.style("width", "200px");

        // Place the obstacle (for collision demonstration)
        obstacleX = width / 2;
        obstacleY = 600;
        obstacleRadius = 80;

        setupCloth();
      }

      // --- Setup Cloth ---
      // We create a grid of corner points (with the top row pinned), then compute midpoints
      // and cell centers. After basic structural constraints are added, we add bending constraints
      // (connecting points two apart) and subdivide each cell into 8 triangles.
      function setupCloth() {
        clothPoints = [];
        clothConstraints = [];
        grid = [];
        horizontal = [];
        vertical = [];
        centers = [];

        // Place the cloth so that UI stays above it.
        let startX = width / 2 - (cols - 1) * spacing / 2;
        let startY = 300;  // cloth starts lower

        // 1. Create grid corner points.
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            let px = startX + x * spacing;
            let py = startY + y * spacing;
            // Pin the top row.
            let pinned = (y === 0);
            clothPoints.push({ x: px, y: py, oldx: px, oldy: py, pinned: pinned });
            grid[y][x] = clothPoints.length - 1;
          }
        }

        // 2. Compute horizontal midpoints.
        for (let y = 0; y < rows; y++) {
          horizontal[y] = [];
          for (let x = 0; x < cols - 1; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y][x + 1];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let mx = (A.x + B.x) / 2;
            let my = (A.y + B.y) / 2;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            horizontal[y][x] = clothPoints.length - 1;
          }
        }

        // 3. Compute vertical midpoints.
        for (let y = 0; y < rows - 1; y++) {
          vertical[y] = [];
          for (let x = 0; x < cols; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y + 1][x];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let mx = (A.x + B.x) / 2;
            let my = (A.y + B.y) / 2;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            vertical[y][x] = clothPoints.length - 1;
          }
        }

        // 4. Compute cell centers.
        for (let y = 0; y < rows - 1; y++) {
          centers[y] = [];
          for (let x = 0; x < cols - 1; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y][x + 1];
            let idxC = grid[y + 1][x];
            let idxD = grid[y + 1][x + 1];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let C = clothPoints[idxC];
            let D = clothPoints[idxD];
            let mx = (A.x + B.x + C.x + D.x) / 4;
            let my = (A.y + B.y + C.y + D.y) / 4;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            centers[y][x] = clothPoints.length - 1;
          }
        }

        // 5. (Optional) Add basic grid constraints (adjacent corner points).
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            let idx = grid[y][x];
            if (x < cols - 1) {
              addConstraint(idx, grid[y][x + 1], spacing);
            }
            if (y < rows - 1) {
              addConstraint(idx, grid[y + 1][x], spacing);
            }
          }
        }

        // 6. Add bending constraints between grid corners two apart.
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols - 2; x++) {
            let idx1 = grid[y][x];
            let idx2 = grid[y][x + 2];
            addConstraint(idx1, idx2, spacing * 2);
          }
        }
        for (let y = 0; y < rows - 2; y++) {
          for (let x = 0; x < cols; x++) {
            let idx1 = grid[y][x];
            let idx2 = grid[y + 2][x];
            addConstraint(idx1, idx2, spacing * 2);
          }
        }

        // 7. Subdivide each cell into 8 triangles.
        // For each cell at (y,x), let:
        //   A = grid[y][x], B = grid[y][x+1], C = grid[y+1][x], D = grid[y+1][x+1]
        //   E = horizontal[y][x] (top midpoint)
        //   F = horizontal[y+1][x] (bottom midpoint)
        //   G = vertical[y][x] (left midpoint)
        //   H = vertical[y][x+1] (right midpoint)
        //   I = centers[y][x] (cell center)
        for (let y = 0; y < rows - 1; y++) {
          for (let x = 0; x < cols - 1; x++) {
            let A = grid[y][x];
            let B = grid[y][x + 1];
            let C = grid[y + 1][x];
            let D = grid[y + 1][x + 1];
            let E = horizontal[y][x];
            let F = horizontal[y + 1][x];
            let G = vertical[y][x];
            let H = vertical[y][x + 1];
            let I = centers[y][x];

            // Top-left corner triangles.
            addConstraint(A, E, distBetween(A, E));
            addConstraint(E, I, distBetween(E, I));
            addConstraint(I, A, distBetween(I, A));

            addConstraint(A, G, distBetween(A, G));
            addConstraint(G, I, distBetween(G, I));
            addConstraint(I, A, distBetween(I, A));

            // Top-right corner triangles.
            addConstraint(B, E, distBetween(B, E));
            addConstraint(E, I, distBetween(E, I));
            addConstraint(I, B, distBetween(I, B));

            addConstraint(B, H, distBetween(B, H));
            addConstraint(H, I, distBetween(H, I));
            addConstraint(I, B, distBetween(I, B));

            // Bottom-left corner triangles.
            addConstraint(C, G, distBetween(C, G));
            addConstraint(G, I, distBetween(G, I));
            addConstraint(I, C, distBetween(I, C));

            addConstraint(C, F, distBetween(C, F));
            addConstraint(F, I, distBetween(F, I));
            addConstraint(I, C, distBetween(I, C));

            // Bottom-right corner triangles.
            addConstraint(D, H, distBetween(D, H));
            addConstraint(H, I, distBetween(H, I));
            addConstraint(I, D, distBetween(I, D));

            addConstraint(D, F, distBetween(D, F));
            addConstraint(F, I, distBetween(F, I));
            addConstraint(I, D, distBetween(I, D));
          }
        }
      }

      // --- Helper Functions ---
      function addConstraint(i, j, len) {
        let a = min(i, j);
        let b = max(i, j);
        for (let c of clothConstraints) {
          if (c.p1 === a && c.p2 === b) return;
        }
        clothConstraints.push({ p1: a, p2: b, length: len });
      }

      function distBetween(i1, i2) {
        let p1 = clothPoints[i1];
        let p2 = clothPoints[i2];
        return sqrt(sq(p2.x - p1.x) + sq(p2.y - p1.y));
      }

      // --- Main Draw Loop ---
      function draw() {
        background(30);

        // Update simulation parameters from sliders.
        friction = frictionSlider.value();
        iterations = iterationsSlider.value();
        gravity = gravitySlider.value();
        weight = weightSlider.value();
        windAmplitude = windSlider.value();

        updateCloth();

        // Draw obstacle.
        noStroke();
        fill(100, 100, 255, 150);
        ellipse(obstacleX, obstacleY, obstacleRadius * 2);

        // Draw constraints.
        stroke(255);
        strokeWeight(2);
        for (let c of clothConstraints) {
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          line(p1.x, p1.y, p2.x, p2.y);
        }

        // Draw points.
        noStroke();
        fill(255, 0, 0);
        for (let p of clothPoints) {
          ellipse(p.x, p.y, 4, 4);
        }

        // Display slider labels and parameter values.
        fill(255);
        noStroke();
        textSize(16);
        text("Friction: " + nf(friction, 1, 2), 240, 75);
        text("Iterations: " + iterations, 240, 115);
        text("Gravity: " + nf(gravity, 1, 2), 240, 155);
        text("Weight: " + nf(weight, 1, 2), 240, 195);
        text("Wind: " + nf(windAmplitude, 1, 2), 240, 235);

        // Educational overlay.
        textAlign(CENTER, CENTER);
        text("Enhanced Cloth Simulation\n(Bending constraints, wind force, obstacle collision,\nselfâ€‘collision & point dragging)", width / 2, 40);
      }

      // --- Simulation Update ---
      function updateCloth() {
        // Verlet integration with wind.
        for (let p of clothPoints) {
          if (!p.pinned) {
            let vx = (p.x - p.oldx) * friction;
            let vy = (p.y - p.oldy) * friction;
            p.oldx = p.x;
            p.oldy = p.y;
            // Wind force oscillates over time.
            let windForce = sin(frameCount * 0.01) * windAmplitude;
            p.x += vx + windForce;
            p.y += vy + gravity * weight;
          }
        }
        // Constraint relaxation.
        for (let i = 0; i < iterations; i++) {
          for (let c of clothConstraints) {
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let distVal = sqrt(dx * dx + dy * dy);
            let diff = (distVal - c.length) / distVal;
            let offsetX = dx * 0.5 * diff;
            let offsetY = dy * 0.5 * diff;
            if (!p1.pinned) {
              p1.x += offsetX;
              p1.y += offsetY;
            }
            if (!p2.pinned) {
              p2.x -= offsetX;
              p2.y -= offsetY;
            }
          }
        }
        // Self-collision: push points apart if too close.
        doSelfCollision();
        // Obstacle collision: push points out of the obstacle.
        doObstacleCollision();
      }

      function doSelfCollision() {
        for (let i = 0; i < clothPoints.length; i++) {
          for (let j = i + 1; j < clothPoints.length; j++) {
            let p1 = clothPoints[i];
            let p2 = clothPoints[j];
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let d = sqrt(dx * dx + dy * dy);
            if (d < collisionThreshold && d > 0) {
              let overlap = collisionThreshold - d;
              let angle = atan2(dy, dx);
              if (!p1.pinned && !p2.pinned) {
                p1.x -= cos(angle) * overlap * repulsionFactor * 0.5;
                p1.y -= sin(angle) * overlap * repulsionFactor * 0.5;
                p2.x += cos(angle) * overlap * repulsionFactor * 0.5;
                p2.y += sin(angle) * overlap * repulsionFactor * 0.5;
              } else if (!p1.pinned && p2.pinned) {
                p1.x -= cos(angle) * overlap * repulsionFactor;
                p1.y -= sin(angle) * overlap * repulsionFactor;
              } else if (p1.pinned && !p2.pinned) {
                p2.x += cos(angle) * overlap * repulsionFactor;
                p2.y += sin(angle) * overlap * repulsionFactor;
              }
            }
          }
        }
      }

      function doObstacleCollision() {
        for (let p of clothPoints) {
          if (!p.pinned) {
            let dx = p.x - obstacleX;
            let dy = p.y - obstacleY;
            let d = sqrt(dx * dx + dy * dy);
            let minDist = obstacleRadius + 4; // small margin
            if (d < minDist) {
              let angle = atan2(dy, dx);
              p.x = obstacleX + cos(angle) * minDist;
              p.y = obstacleY + sin(angle) * minDist;
            }
          }
        }
      }

      // --- Point Dragging ---
      function mousePressed() {
        // Only allow dragging if the press is below the UI area.
        if (mouseY > 250) {
          let nearestIndex = -1;
          let nearestDist = Infinity;
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            let d = dist(mouseX, mouseY, p.x, p.y);
            if (d < 15 && d < nearestDist) {
              nearestIndex = i;
              nearestDist = d;
            }
          }
          if (nearestIndex !== -1) {
            dragPointIndex = nearestIndex;
          }
        }
      }

      function mouseDragged() {
        if (dragPointIndex !== null) {
          let p = clothPoints[dragPointIndex];
          p.x = mouseX;
          p.y = mouseY;
        }
      }

      function mouseReleased() {
        dragPointIndex = null;
      }

      // --- Reset & Resize ---
      function resetCloth() {
        setupCloth();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        obstacleX = width / 2;
        setupCloth();
      }
    </script>
  </body>
</html>
