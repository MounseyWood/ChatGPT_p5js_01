<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Cloth Simulation with 8-Triangle Cells</title>
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
  </head>
  <body>
    <script>
      // Grid parameters: number of grid corners (rows x cols) and spacing between them.
      let cols = 30;
      let rows = 20;
      let spacing = 20;
      
      // Arrays to hold all simulation points and constraints.
      let clothPoints = [];
      let clothConstraints = [];
      
      // 2D arrays to hold indices for:
      // - grid: the original corner points (dimensions: rows x cols)
      // - horizontal: midpoints on horizontal edges (rows x (cols-1))
      // - vertical: midpoints on vertical edges ((rows-1) x cols)
      // - centers: center point of each cell ((rows-1) x (cols-1))
      let grid = [];
      let horizontal = [];
      let vertical = [];
      let centers = [];
      
      // Simulation parameters.
      let friction = 0.98;
      let iterations = 5;
      let gravity = 0.4;
      
      // UI element: reset button.
      let resetButton;
      
      function setup() {
        createCanvas(windowWidth, windowHeight);
        resetButton = createButton("Reset Cloth");
        resetButton.position(20, 20);
        resetButton.style("font-size", "16px");
        resetButton.mousePressed(resetCloth);
        
        setupCloth();
      }
      
      // Helper: Add a constraint between two points (if not already added)
      function addConstraint(i, j, len) {
        // Order indices to check uniqueness.
        let a = min(i, j);
        let b = max(i, j);
        // Check if this constraint exists.
        for (let c of clothConstraints) {
          if (c.p1 === a && c.p2 === b) {
            return;
          }
        }
        clothConstraints.push({ p1: a, p2: b, length: len });
      }
      
      // Sets up the cloth simulation:
      // 1. Create grid corner points (with top row pinned)
      // 2. Compute horizontal edge midpoints, vertical edge midpoints, and cell centers.
      // 3. Add constraints: first, add basic grid constraints (optional) and then subdivide each cell into 8 triangles.
      function setupCloth() {
        clothPoints = [];
        clothConstraints = [];
        grid = [];
        horizontal = [];
        vertical = [];
        centers = [];
        
        // Determine starting positions so that the cloth is horizontally centered and a bit below the top.
        let startX = width / 2 - (cols - 1) * spacing / 2;
        let startY = 100;
        
        // 1. Create grid corners.
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            let px = startX + x * spacing;
            let py = startY + y * spacing;
            // Pin the top row so the fabric hangs.
            let pinned = (y === 0);
            clothPoints.push({ x: px, y: py, oldx: px, oldy: py, pinned: pinned });
            grid[y][x] = clothPoints.length - 1;
          }
        }
        
        // 2. Compute horizontal edge midpoints (for each row between adjacent grid corners).
        for (let y = 0; y < rows; y++) {
          horizontal[y] = [];
          for (let x = 0; x < cols - 1; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y][x + 1];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let mx = (A.x + B.x) / 2;
            let my = (A.y + B.y) / 2;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            horizontal[y][x] = clothPoints.length - 1;
          }
        }
        
        // 3. Compute vertical edge midpoints (for each column between adjacent grid corners).
        for (let y = 0; y < rows - 1; y++) {
          vertical[y] = [];
          for (let x = 0; x < cols; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y + 1][x];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let mx = (A.x + B.x) / 2;
            let my = (A.y + B.y) / 2;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            vertical[y][x] = clothPoints.length - 1;
          }
        }
        
        // 4. Compute cell centers (for each cell defined by 4 grid corners).
        for (let y = 0; y < rows - 1; y++) {
          centers[y] = [];
          for (let x = 0; x < cols - 1; x++) {
            let idxA = grid[y][x];
            let idxB = grid[y][x + 1];
            let idxC = grid[y + 1][x];
            let idxD = grid[y + 1][x + 1];
            let A = clothPoints[idxA];
            let B = clothPoints[idxB];
            let C = clothPoints[idxC];
            let D = clothPoints[idxD];
            let mx = (A.x + B.x + C.x + D.x) / 4;
            let my = (A.y + B.y + C.y + D.y) / 4;
            clothPoints.push({ x: mx, y: my, oldx: mx, oldy: my, pinned: false });
            centers[y][x] = clothPoints.length - 1;
          }
        }
        
        // (Optional) Add grid constraints for adjacent corner points.
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            let idx = grid[y][x];
            // Horizontal connection.
            if (x < cols - 1) {
              let right = grid[y][x + 1];
              addConstraint(idx, right, spacing);
            }
            // Vertical connection.
            if (y < rows - 1) {
              let below = grid[y + 1][x];
              addConstraint(idx, below, spacing);
            }
          }
        }
        
        // 5. For each cell, subdivide into 8 triangles.
        // For cell at (y,x): corners:
        //   A = grid[y][x], B = grid[y][x+1], C = grid[y+1][x], D = grid[y+1][x+1]
        // Edge midpoints:
        //   E (top): horizontal[y][x]
        //   F (bottom): horizontal[y+1][x]
        //   G (left): vertical[y][x]
        //   H (right): vertical[y][x+1]
        // Center: I = centers[y][x]
        for (let y = 0; y < rows - 1; y++) {
          for (let x = 0; x < cols - 1; x++) {
            let A = grid[y][x];
            let B = grid[y][x + 1];
            let C = grid[y + 1][x];
            let D = grid[y + 1][x + 1];
            let E = horizontal[y][x];         // top edge between A and B
            let F = horizontal[y + 1][x];       // bottom edge between C and D
            let G = vertical[y][x];             // left edge between A and C
            let H = vertical[y][x + 1];         // right edge between B and D
            let I = centers[y][x];              // center of the cell
            
            // For each triangle, calculate the rest length from current positions.
            // Top-left corner triangles:
            addConstraint(A, E, distBetween(A, E));
            addConstraint(E, I, distBetween(E, I));
            addConstraint(I, A, distBetween(I, A));
            
            addConstraint(A, G, distBetween(A, G));
            addConstraint(G, I, distBetween(G, I));
            addConstraint(I, A, distBetween(I, A));
            
            // Top-right corner triangles:
            addConstraint(B, E, distBetween(B, E));
            addConstraint(E, I, distBetween(E, I));
            addConstraint(I, B, distBetween(I, B));
            
            addConstraint(B, H, distBetween(B, H));
            addConstraint(H, I, distBetween(H, I));
            addConstraint(I, B, distBetween(I, B));
            
            // Bottom-left corner triangles:
            addConstraint(C, G, distBetween(C, G));
            addConstraint(G, I, distBetween(G, I));
            addConstraint(I, C, distBetween(I, C));
            
            addConstraint(C, F, distBetween(C, F));
            addConstraint(F, I, distBetween(F, I));
            addConstraint(I, C, distBetween(I, C));
            
            // Bottom-right corner triangles:
            addConstraint(D, H, distBetween(D, H));
            addConstraint(H, I, distBetween(H, I));
            addConstraint(I, D, distBetween(I, D));
            
            addConstraint(D, F, distBetween(D, F));
            addConstraint(F, I, distBetween(F, I));
            addConstraint(I, D, distBetween(I, D));
          }
        }
      }
      
      // Helper: compute distance between two points by their indices in clothPoints.
      function distBetween(i1, i2) {
        let p1 = clothPoints[i1];
        let p2 = clothPoints[i2];
        return sqrt(sq(p2.x - p1.x) + sq(p2.y - p1.y));
      }
      
      function draw() {
        background(30);
        updateCloth();
        
        // Draw all constraints.
        stroke(255);
        strokeWeight(2);
        for (let c of clothConstraints) {
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          line(p1.x, p1.y, p2.x, p2.y);
        }
        
        // Optionally draw all points.
        noStroke();
        fill(255, 0, 0);
        for (let p of clothPoints) {
          ellipse(p.x, p.y, 4, 4);
        }
        
        // On-screen instructions.
        fill(255);
        noStroke();
        textSize(16);
        textAlign(CENTER, CENTER);
        text("Touch/drag to poke the cloth. Press 'Reset Cloth' to restart.", width / 2, 40);
      }
      
      // Update the cloth simulation using Verlet integration and constraint relaxation.
      function updateCloth() {
        // Verlet integration for each point.
        for (let p of clothPoints) {
          if (!p.pinned) {
            let vx = (p.x - p.oldx) * friction;
            let vy = (p.y - p.oldy) * friction;
            p.oldx = p.x;
            p.oldy = p.y;
            p.x += vx;
            p.y += vy + gravity;
          }
        }
        // Relax constraints multiple times.
        for (let i = 0; i < iterations; i++) {
          for (let c of clothConstraints) {
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let distVal = sqrt(dx * dx + dy * dy);
            let diff = (distVal - c.length) / distVal;
            let offsetX = dx * 0.5 * diff;
            let offsetY = dy * 0.5 * diff;
            if (!p1.pinned) {
              p1.x += offsetX;
              p1.y += offsetY;
            }
            if (!p2.pinned) {
              p2.x -= offsetX;
              p2.y -= offsetY;
            }
          }
        }
      }
      
      // On touch or drag, "poke" nearby points.
      function touchMoved() {
        for (let t of touches) {
          let tx = t.x;
          let ty = t.y;
          for (let p of clothPoints) {
            let d = dist(tx, ty, p.x, p.y);
            let radius = 50;
            if (d < radius) {
              let strength = (radius - d) * 0.2;
              let angle = atan2(p.y - ty, p.x - tx);
              p.x += cos(angle) * strength;
              p.y += sin(angle) * strength;
            }
          }
        }
        return false; // Prevent scrolling.
      }
      
      // Reset the simulation.
      function resetCloth() {
        setupCloth();
      }
      
      // On window resize, reinitialize the cloth.
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        setupCloth();
      }
    </script>
  </body>
</html>
