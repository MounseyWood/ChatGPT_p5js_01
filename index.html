<script>
  let cloth = [];
  let clothConstraints = [];
  let cols = 20;
  let rows = 15;
  let spacing = 15;
  let clothG;

  function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL);
    clothG = createGraphics(windowWidth, windowHeight);
    setupCloth();
  }

  function draw() {
    background(0);

    // 1. Parallax planes
    drawParallax();

    // 2. Rotating 3D box
    push();
      rotateY(frameCount * 0.01);
      rotateX(frameCount * 0.01);
      fill(200, 50, 50);
      noStroke();
      box(100);
    pop();

    // 3. Cloth simulation (drawn on clothG)
    clothG.clear();
    clothG.stroke(255);
    clothG.strokeWeight(2);
    updateCloth();
    for (let c of clothConstraints) {
      let p1 = cloth[c.p1];
      let p2 = cloth[c.p2];
      clothG.line(p1.x, p1.y, p2.x, p2.y);
    }
    for (let p of cloth) {
      clothG.fill(255, 0, 0);
      clothG.noStroke();
      clothG.ellipse(p.x, p.y, 4);
    }
    push();
      translate(-width / 2, -height / 2);
      image(clothG, 0, 0, width, height);
    pop();

    // 4. Kinetic text
    drawKineticText();

    // Remove or comment out the filter if it causes issues in WEBGL
    // filter(POSTERIZE, 4);
  }

  function drawParallax() {
    let numLayers = 3;
    for (let i = 0; i < numLayers; i++) {
      push();
        let z = -500 + i * 200;
        translate(0, 0, z);
        let factor = (i + 1) / numLayers;
        let offsetX = map(mouseX, 0, width, -20, 20) * factor;
        let offsetY = map(mouseY, 0, height, -20, 20) * factor;
        translate(offsetX, offsetY, 0);
        fill(50 + i * 40, 100, 150);
        noStroke();
        plane(width, height);
      pop();
    }
  }

  function drawKineticText() {
    push();
      resetMatrix();
      textAlign(CENTER, CENTER);
      textSize(48);
      fill(255);
      let tX = windowWidth / 2 + sin(frameCount * 0.05) * 100;
      let tY = windowHeight / 2 + cos(frameCount * 0.05) * 50;
      text("Creative Code", tX, tY);
    pop();
  }

  function setupCloth() {
    cloth = [];
    clothConstraints = [];
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let px = x * spacing + (windowWidth / 2 - (cols * spacing) / 2);
        let py = y * spacing + (windowHeight - rows * spacing - 50);
        cloth.push({
          x: px,
          y: py,
          oldx: px,
          oldy: py,
          pinned: y === 0
        });
      }
    }
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let idx = x + y * cols;
        if (x < cols - 1) {
          clothConstraints.push({ p1: idx, p2: idx + 1, length: spacing });
        }
        if (y < rows - 1) {
          clothConstraints.push({ p1: idx, p2: idx + cols, length: spacing });
        }
      }
    }
  }

  function updateCloth() {
    let gravity = 0.5;
    let friction = 0.99;
    for (let p of cloth) {
      if (!p.pinned) {
        let vx = (p.x - p.oldx) * friction;
        let vy = (p.y - p.oldy) * friction;
        p.oldx = p.x;
        p.oldy = p.y;
        p.x += vx;
        p.y += vy + gravity;
      }
    }
    for (let i = 0; i < 5; i++) {
      for (let c of clothConstraints) {
        let p1 = cloth[c.p1];
        let p2 = cloth[c.p2];
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        let dist = sqrt(dx * dx + dy * dy);
        let diff = (dist - c.length) / dist;
        let offsetX = dx * 0.5 * diff;
        let offsetY = dy * 0.5 * diff;
        if (!p1.pinned) {
          p1.x += offsetX;
          p1.y += offsetY;
        }
        if (!p2.pinned) {
          p2.x -= offsetX;
          p2.y -= offsetY;
        }
      }
    }
  }

  function windowResized() {
    resizeCanvas(windowWidth, windowHeight, WEBGL);
    clothG.resizeCanvas(windowWidth, windowHeight);
    setupCloth();
  }
</script>
